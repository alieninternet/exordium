void dbConnect(void)

	Objective: Connect to the database. This is used when services start.

void dbDisconnect(void)

	Objective: Disconnect from database. This is used when services stop.


int dbSelect(AISutil::String const &table)

	Objective: Send query to server under form SELECT * from <table>
        Returns:   Number of rows returned by the query

int dbSelect(AISutil::String const &fields, AISutil::String const &table)

	Objective: Send query to server under form SELECT <fields> from <table>
        Returns:   Number of rows returned by the query


int dbSelect(AISutil::String const &fields, AISutil::String const &table, AISutil::String const &whereargs)

	Objective: Send query to server under form SELECT <fields> FROM <table> WHERE <whereargs>
        Returns:   Number of rows returned by the query


int dbSelect(AISutil::String const &fields, AISutil::String const &table, AISutil::String const &whereargs,AISutil::String const &orderargs)

        Objective: Send query to server under form SELECT <fields> FROM <table> WHERE <whereargs> ORDER BY <orderargs>
        Returns:   Number of rows returned by the query


int dbCount(AISutil::String const &table)

        Objective: Send query to server under form SELECT count(*) FROM <table>
        Returns:   Result of the query


int dbCount(AISutil::String const &table, AISutil::String const &whereargs)

        Objective: Send query to server under form SELECT count(*) FROM <table> WHERE <whereargs>
	Returns:   Result of the query


void dbInsert(AISutil::String const &table,  AISutil::String const &values)

        Objective: Send query to server under form INSERT into <table> VALUES( <values> )


void dbUpdate(AISutil::String const &table, AISutil::String const &values, AISutil::String const &whereargs)

	Objective: Send query to server under form UPDATE <table> SET <values> WHERE <whereargs>


void dbDelete(AISutil::String const &table, AISutil::String const &whereargs)

	Objective: Send query to server under form DELETE FROM <table> WHERE <whereargs>

void dbDelete(AISutil::String const &table)

	Objective: Send query to server under form DELETE FROM <table>

AISutil::String dbGetValue(void)

	Objective: Get the 1st value of the current row ( shortcut to dbGetValue(0) )
        Returns:   Value at the position 0 of the current row

AISutil::String dbGetValue(int field)

	Objective: Get the n value of the current row.
	Returns:   Value at the position n of the current row.


void dbGetRow(void)

	Objective: Make next row the current row. Used in for loops.



IMPORTANT NOTE:

        After a succesfull SELECT, you are automatically set on the 1st row. You can take the values immediately.


EXAMPLES:


// if the select generates less than 1 row(ie no result), return 0.
// else return the 1st value of 1st row.

if( database.dbSelect("id", "onlineclients", "nickname='"+newnick+"'") < 1 )
   {
     Debug("ERROR: Returning 0 (NOT KNOWN) from getOnlineNickID");
     return 0;
   }
   else
     return database.dbGetValue().toInt();


// Loop example:


// First we get the number of rows generated by the SELECT
int nbRes = database.dbSelect("id,chan,mask", "chanbans", "expireon<"+ctime);

for(int i=0; i<nbRes; i++)
{
   // Fetch the needed values
   channel.RemoveBan(database.dbGetValue(0), database.dbGetValue(1), database.dbGetValue(2));

   // Then switch to next row. If you forget to do this you will always get the values of the 1st row.
   database.dbGetRow();
}


// Count example:

// There is no validation to make since the count() returns 0 if there's no result.
return database.dbCount("notes", "nto='"+who+"'");



// Update example:

// UPDATE onlineclients SET nickname='newnick' WHERE id=...
database.dbUpdate("onlineclients", "nickname='"+newnick+"'", "id="+who.getOnlineIDString());




// UNDER THE HOOD


On each Insert/Update/Delete, here is what happens:

1-Write Lock the table (Note: explicit locking is done for MySQL, it is ignored for PostgreSQL since locking is automatic)
2-Begin transaction (Note: MySQL is set on auto-commit by default so it is ignored, we should discuss the use of SET 
                           AUTOCOMMIT=0)
3-Query is issued
4-Commit is issued (Note: for those not on auto-commit)
5-Unlock
